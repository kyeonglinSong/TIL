190923(월)

## 16장. 비트마스크(bitmask)



#### 1. 비트마스크 

: 정수의 이진수 표현을 자료 구조로 쓰는 기법

- 비트마스크의 장점

  - 더 빠른 수행 시간 : 비트마스크 연산은 대부분 O(1)

  - 더 간결한 코드 : 코드를 반복문 없이 한 줄에 작성 가능

  - 더 작은 메모리 용량 

  - 연관 배열을 배열로 대체

    ```c++
    map<vector<bool>, int> // 를
    int[]									 // 로 대체 가능
    ```

- 유의할 점들

  - 연산자 우선순위 : ==, != 보다 &, |, ^ , ~ 가 우선순위가 낮다.
  - 오버플로우 
    - C++에서는 상수 1이 부호 있는 32bit 상수로 취급됨.
    - 64bit와 32bit간의 연산에서 주의해야 함.
    - 1을 부호 없는 64bit 정수로 취급할 때 : ull 붙임
  - 부호 있는 정수형의 사용
  - N 이상 시프트 : 컴퓨터 환경에 따라 결과가 다르다.





#### 2. 비트마스크를 이용한 집합의 구현

- N비트 정수는 0 ~ N-1 까지 정수의 집합을 나타낼 수 있다.



- 피자집 예제

  - 공집합과 꽉 찬 집합 구하기

  ```C++
  int emptyPizza = 0;
  int fullPizza = (1 >> 20) - 1;
  ```

  - 원소 추가 / 삭제 / 포함여부 확인 / 토글

  ```c++
  // 원소 추가 : 해당 비트를 켬
  toppings |= (1 << p);
  
  // 원소 삭제 : 해당 비트를 끔
  toppings -= (1 << p);  // 없는데 또 뺄 경우에는 문제 생김
  toppings &= ~(1 << p); // 문제 안생김
  
  // 원소의 포함여부 확인
  if(toppings & (1<<p))
    cout << "pepperoni is in" << endl; // 있으면 1, 없으면 0 반환된다.
  
  // 토클 : 꺼져있으면 켜고 켜져있으면 끔
  toppings ^= (1<<p);
  
  ```

  - 두 집합에 대한 연산 / 크기 구하기

  ```c++
  // 집합 연산
  int added = (a|b);         // 교집합
  int intersection = (a&b);  // 합집합
  int removed = (a&~b);			 // 차집합 (a-b)
  int toggled = (a^b);			 // 하나에만 포함된 원소들의 집합 
  
  // 크기 구하기 : 켜져있는 비트 일일이 세기
  int bitCount(int x)
  {
    if(x==0)
      return 0;
    return x%2 + bitCount(x/2);
  }
  
  ```

  - 최소 원소 찾기 / 지우기

  ```c++
  // 최하위 비트 찾기 : 끝에 붙어있는 0이 몇개인가
  int firstTopping = (toppings & -toppings);
  
  // 최소 원소 지우기
  toppings &= (toppings -1);
  ```

  - 모든 부분집합 순회하기

  ```c++
  for(int i=pizza ; i ; i=((i-1)&pizza)) {}
  ```

  

