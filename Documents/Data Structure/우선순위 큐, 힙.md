191115(금)

#우선순위 큐, 힙



둘 다 우선순위 가 있다.

- 우선순위 큐 : 연결리스트나 배열에 원소를 모두 집어넣고, 순회하며 우선순위가 높은 것 부터 꺼냄 (O(n))

- 힙 : 가장 큰 원소를 찾는 데 최적화된 이진 트리(O(lgN))



### 1.힙(heap)

부모 노드는 항상 자식 노드보다 커야 함. 즉 트리에서 가장 큰 원소는 루트에 위치한다.



힙의 규칙 - 항상 트리가 이상적인 형태를 띠도록 도와준다.

- 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차있어야 한다.
- 마지막 레벨에 노드가 있을 때는 항상 가장 왼쪽부터 순서대로채워져 있어야 한다.



#### 1.1. 배열을 이용한 힙의 구현

```c++
vector<int> heap;

// a[i]의 왼쪽 자손은 a[2*i+1] 이다.
// a[i]의 오른쪽 자손은 a[2*i+2] 이다.
// a[i]의 부모는 a[(i-1)/2] 이다.
```



#### 1.2. 새 원소의 삽입

```c++
void push_heap(vector<int>& heap, int newValue)
{
  heap.push_back(newValue); // 트리의 맨 마지막에 newValue를 삽입한다.
  int index = heap.size()-1; // 현재 newValue의 위치
  
  // 루트에 도달하거나, newValue 이상의 값을 만날 때 까지
  while( (index > 0) && (heap[(index-1)/2] < heap[index]) )
  {
    swap(heap[index], heap[(index-1)/2]);
    index = (index-1)/2;
  }
}
```



#### 1.3. 최대 원소 꺼내기 

루트에 제일 작은 원소를 덮어씌움 -> 맨 뒤 원소 삭제 -> 루트의 원소를 자기 자리로 다시 내리기

```c++
void pop_heap(vector<int>& heap)
{
  heap[0] = heap.back();
  heap.pop_back(); // 맨 뒤 원소 삭제
  int here = 0; // 현재 루트원소의 위치
  while(true)
  {
    int left = here*2 + 1;
    int right = here*2 + 2;
    if(left >= heap.size()) // 리프일때
      break; 
    int next = here;
    if(heap[next] < heap[left])
      next = left;
    if(right < heap.size() && heap[next]<heap[right])
      next = right;
    if(next == here)
      break;
    swap(heap[here], heap[next]);
    here = next;
  }
  
}
```

 