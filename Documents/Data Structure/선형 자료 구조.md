190926(목)

## 18장. 선형 자료 구조

- 동적 배열, 연결리스트



#### 1. 동적 배열

: 메모리의 연속된 위치에 원소들이 저장되어 있다.

- 탐색 쉬움 / 삽입삭제 어려움

- resize(), append() 지원

- 동적 배열 클래스의 구조

  ```c++
  int size; // 배열의 사이즈
  ElementType* array; // 배열을 가리키는 포인터
  ```

-  append() 연산 시 할당해놓은 배열이 다 찼을 때

  ```c++
  if(size==capacity){
    // M 만큼 늘어난 새 배열
    int newCapacity = capacity + M;
   	int* newArray = new int[newCapacity];
    // 기존 자료 복사
    for(int i=0 ; i<size ; ++i)
      newArray[i] = array[i];
    if(array)
      delete [] array;
    array = newArray;
    capacity = newCapacity;
  }
  array[size++] = newValue;
  ```

  - 상수 시간 내에 append()를 구현하기 위해, resize()가 일어날 때마다 용량을 2배씩 늘린다.
    - 전체 수행 : 2^k-1 = O(N) 이므로 한번 수행 : O(N)/N = O(1)

- C++에서는 stl의 vector를 사용하면 된다.





#### 2. 연결 리스트

: 원소들이 메모리 여기저기에 흩어져 있고, 앞뒤 원소를 가리키는 포인터를 가지고 있다.

- 특정 위치에서이 삽입/삭제를 상수 시간 내에 가능하게 해준다.

- 연결 리스트 구조

  ```c++
  struct ListNode{
    int element;
    ListNode *prev, *next;
  }
  ```

  

- 탐색 어려움 / 삽입삭제 쉬움

- C++ stl의 list

- 연결리스트 응용 연산 (잘 안쓰임)

  - 잘라 붙이기 연산(splicing)

    - 다른 리스트의 일부를 중간에 붙일 수 있다.
    - 대신 리스트 크기를 O(1) 에 알기 어렵다.
    - c++ stl에는 splice()가 존재하기는 한다.

  - 삭제했던 원소 되돌려놓기

    - 양방향 연결 리스트의 장점 중 하나.

    ```c++
    // 노드 삭제 연산
    void deleteNode(ListNode* node){
      node->prev->next = node->next;
      node->next->prev = node->prev;
    }
    // 삭제한 노드를 다시 되돌려놓는 연산
    void recoverNode(ListNode* node){
      node->prev->next = node;
      node->next->prev = node;
    }
    ```

    - Knuth - dancing links 나중에 찾아보자





#### 3. 동적 배열과 연결리스트의 비교

- 탐색 / 삽입삭제 에 걸리는 시간이 가장 큰 차이점
  - 배열의 끝에서만 접근한다 -> 동적배열
  - 모든 원소들을 순회 / 삽입삭제를 한다 -> 연결리스트